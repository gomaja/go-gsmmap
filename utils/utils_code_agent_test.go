// Test code generated by code-agent (AI agent). DO NOT EDIT MANUALLY.
// Purpose:
// - To increase coverage
//

package utils

import (
	"encoding/hex"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestBCDEncoding_Agent(t *testing.T) {
	cases := []struct {
		description string
		str         string
		bytes       []byte
	}{
		{
			"imsi_even",
			"1234567890",
			[]byte{0x21, 0x43, 0x65, 0x87, 0x09},
		},
	}

	for _, c := range cases {
		t.Run("Str2Bytes/"+c.description, func(t *testing.T) {
			swapped, err := EncodeTBCDDigits(c.str)
			if err != nil {
				t.Fatal(err)
			}

			if diff := cmp.Diff(swapped, c.bytes); diff != "" {
				t.Error(diff)
			}
		})

		t.Run("Bytes2Str/"+c.description, func(t *testing.T) {
			str, err := DecodeTBCDDigits(c.bytes)
			if err != nil {
				t.Fatal(err)
			}

			if diff := cmp.Diff(str, c.str); diff != "" {
				t.Error(diff)
			}
		})
	}
}

func TestBCDEncodingErrors(t *testing.T) {
	t.Run("EncodeInvalidChar", func(t *testing.T) {
		_, err := EncodeTBCDDigits("123G")
		if err == nil {
			t.Error("expected error for invalid character")
		}
	})

	t.Run("DecodeNil", func(t *testing.T) {
		_, err := DecodeTBCDDigits(nil)
		if err == nil {
			t.Error("expected error for nil input")
		}
	})
}

func TestGSNAddress(t *testing.T) {
	cases := []struct {
		description string
		ipStr       string
		encodedHex  string
		wantType    int // 0 for IPv4, 1 for IPv6
	}{
		{
			"IPv4",
			"192.168.1.1",
			"04c0a80101", // Type=0 (00), Len=4 (000100) -> 0x04. IP=C0A80101
			0,
		},
		{
			"IPv6",
			"2001:db8::1",
			"5020010db8000000000000000000000001", // Type=1 (01), Len=16 (010000) -> 0x50.
			1,
		},
	}

	for _, c := range cases {
		t.Run("Build/"+c.description, func(t *testing.T) {
			encoded, err := BuildGSNAddress(c.ipStr)
			if err != nil {
				t.Fatalf("BuildGSNAddress failed: %v", err)
			}
			encodedHex := hex.EncodeToString(encoded)
			if encodedHex != c.encodedHex {
				t.Errorf("got %s, want %s", encodedHex, c.encodedHex)
			}
		})

		t.Run("Parse/"+c.description, func(t *testing.T) {
			data, err := hex.DecodeString(c.encodedHex)
			if err != nil {
				t.Fatalf("hex decoding failed: %v", err)
			}
			ipStr, err := ParseGSNAddress(data)
			if err != nil {
				t.Fatalf("ParseGSNAddress failed: %v", err)
			}
			if ipStr != c.ipStr {
				t.Errorf("got %s, want %s", ipStr, c.ipStr)
			}
		})
	}
}

func TestGSNAddressErrors(t *testing.T) {
	t.Run("BuildInvalidIP", func(t *testing.T) {
		_, err := BuildGSNAddress("invalid-ip")
		if err == nil {
			t.Error("expected error for invalid IP")
		}
	})

	t.Run("ParseEmpty", func(t *testing.T) {
		_, err := ParseGSNAddress([]byte{})
		if err == nil {
			t.Error("expected error for empty data")
		}
	})

	t.Run("ParseTooShort", func(t *testing.T) {
		// Type 0, Len 4, but only 2 bytes provided
		data := []byte{0x04, 0x01, 0x02}
		_, err := ParseGSNAddress(data)
		if err == nil {
			t.Error("expected error for short data")
		}
	})

	t.Run("ParseInvalidLengthIPv4", func(t *testing.T) {
		// Type 0 (IPv4), but Len 5
		// Header: 00 000101 -> 0x05
		data := []byte{0x05, 1, 2, 3, 4, 5}
		_, err := ParseGSNAddress(data)
		if err == nil {
			t.Error("expected error for invalid IPv4 length")
		}
	})

	t.Run("ParseInvalidLengthIPv6", func(t *testing.T) {
		// Type 1 (IPv6), but Len 4
		// Header: 01 000100 -> 0x44
		data := []byte{0x44, 1, 2, 3, 4}
		_, err := ParseGSNAddress(data)
		if err == nil {
			t.Error("expected error for invalid IPv6 length")
		}
	})

	t.Run("ParseUnknownType", func(t *testing.T) {
		// Type 2 (10), Len 4
		// Header: 10 000100 -> 0x84
		data := []byte{0x84, 1, 2, 3, 4}
		_, err := ParseGSNAddress(data)
		if err == nil {
			t.Error("expected error for unknown type")
		}
	})
}
